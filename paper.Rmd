---
title: "plyranges: a grammar for manipulating genomics data" 
author:
  - name: Stuart Lee
    email: stuart.lee1@monash.edu
    affiliation: Monash University
  - name: Michael Lawrence
    email: michael.lawrence@gene.com
    affiliation: Genentech
  - name: Di Cook
    email: di.cook@monash.edu
    affiliation: Monash University
address:
  - code: Monash University
    address: Department of Econometrics and Business Statistics, Clayton, Victoria, Australia
  - code: Genentech
    address: Bioinformatics and Computational Biology, Genentech, Inc., South San Francisco, California, United States of America 
abstract: |
    The Bioconductor project has created many powerful abstractions for reasoning about genomics data, such as the _Ranges_ data structures for representing genomic intervals. By recognising that these data structures follow 'tidy' data principles we have created a grammar of genomic data manipulation that defines verbs for performing actions on and between genomic interval data. This grammar simplifies performing common genomic data analysis tasks via method chaining, type consistency and results in creating human readable pipelines. We have implemented this grammar as an Bioconductor/R package called plyranges.
  

bibliography: references.bib
output: rticles::plos_article
csl: plos.csl
---

# Introduction

Genomic data may be naturally represented as sets of pairs of integers 
corresponding to the start and end points of sequences. Further information
such as strandedness and chromosome name may be added to these sets to 
provide biological context. Because of the flexibility of this representation 
supplemental information such as measurements obtained from an experimental 
assay or annotations from a genome database can be joined to their relevant
sequences. In the Bioconductor/R packages `IRanges` and `GenomicRanges` these representations have been implemented as a suite of data structures called _Ranges_ @Lawrence2013-wg. These data structures cover many common data types encountered in bioinformatics analyses - a gene can be represented with its coordinates, along with its identifier and the identifiers of its exons; or
an RNA-seq experiment may be represented as sets of genes with a matching count column.

The Bioconductor infrastructure for computing with genomic ranges are highly 
effecient and powerful, however the application programming interface (API) for performing analysis tasks with _Ranges_ is complex due to its large number of
methods and classes. It also makes resulting scripts written 
difficult for a non-programmer to read and reason about. An alternative approach 
would be to implement a domain specific language (DSL) as a fluent interface 
built on top _Ranges_. The goal of fluent interface is to enable users to write 
human-readable code via method chaining and consistent function returns. Fluent 
interfaces fit naturally in the context of Bioinformatics workflows because they 
enable writing succinct pipelines.

Several other DSLs have been implemented to reason about genomics data. Broadly, 
these are either implemented as query languages or as command line tools 
embedded in the unix environment ^[other ideas to mention GROK @Ovaska2013-gd]. An example of the former is the Genome Query Language (GQL) and its distributed 
implementation GenAp which use an SQL-like syntax for fast retrieval of 
information from genomic databases and BAM files @Kozanitis2014-va; @Kozanitis2016-bm. 
Another  example is the Genometric Query Language (GMQL) which implements a relational algebra for combining big genomic datasets @Kaitoua2017-pw.  The command line application 
BEDtools develops an extensive algebra for performing arithmetic between two or 
more sets of genomic regions  @Quinlan2010-gc. It also has a python interface 
which simplifies construcing scripts for performing analyses based on BEDTools  @Dale2011-js. ^[probably should also mention something about their cons, and more detaiil]

The abstraction provided by the _Ranges_ data structures aligns with the concept
of tidy data @Wickham2014-jc. The tidy data pattern is useful because it allows us to see how the data relates to the design of an experiment
and the variables measured. Consequently, it makes both the modelling and manipulation of data more systematic. The _Ranges_ data structure follows this abstraction: it is a rectanglular table corresponding to a single biological context. Each row contains a single observation and each column a variable about that observation. 

The tidy data abstraction has motivated the development of `plyranges`
a grammar of genomic data manipulation based on the _Ranges_ data structures. It
implements and extends the grammar defined by the R package `dplyr` @Wickham2017-dplyr. The grammar provides a consistent way of interacting with and analysing genomic data via methods for constructing, grouping, mutating, filtering, and summarising _Ranges_ and an algebra for reasoning about actions on _Ranges_ and relationships between _Ranges_.

# Design and Implementation

The _plyranges_ API implements a domain specific language using the existing
_IRanges_ and _GenomicRanges_ packages in Bioconductor as a backend. Consequently,
our API still has the speed and effeciency of the aforementioned packages but
with a more coherent interface. The API also
extends the grammar elements in _dplyr_ for performing genomic specific
manipulations such as finding overlapping regions or nearest neighbour regions
between many _Ranges_. The _plyranges_ API is specifically designed to enable
fast interactive analysis of _Ranges_ objects but can also be used for scripting 
genomic data workflows.

We have desgined the API to be fluent. Every function call corresponds to an
action on a _Ranges_ object (they are named verbs) and where possible
functions have few arguments. Each verb is constructed
to enable a tab completion based workflow. Both of these aspects reduce the 
cognitive load on a new user  since most manipulations can be performed with a 
vocabulary of several verbs, rather than having to memorise functions with many 
arguments that are nouns (as is required in the existing Bioconductor packages). 
This is also has the advantage of allowing users to write human readable code
because verbs describe what the code is doing rather than how its doing it.

Workflows can be composed by chaining verbs together via the pipe operator,`%>%` 
(exported from the R package _magrittr_). This is possible because every 
function call is endomorphic: when the input is _Ranges_ object the output
will also be a _Ranges_ object. One advantage of this static typing is that it 
does not  require any additional learning of classes beyond _Ranges_ and 
the _DataFrame_ classes. This is similar to the bedtools API, where the
output is usually a BED file. However, it strongly deviates from the design of 
the _Ranges_ Bioconductor packages, where many methods return a new class
upon return. The Bioconductor design enables effecient computing as users
are exposed to low-level features of its API which _plyranges_ trys to abstract
away. Method chaining via the pipe operator can also be difficult to debug,
as there multiple points of failure.

## Working with Ranges

### Core verbs

The _plyranges_ API exports the six core verbs from the _dplyr_ package
and modifys them for use with simple _Ranges_ and _Genomic Ranges_. The
verb `mutate()` takes a Ranges object and a set of name-value pairs
and generates a new Ranges object that with modified or new metadata
columns or modified core components (start, end, width, seqnames, strand).
The use of `mutate()` means that a user no longer needs knowledge of the 
accessors of the Ranges object, as they can modify them in place.
The `filter()` function takes a Ranges object and logical expressions and
restricts Ranges object to where the logical expression evaluates to true.
The `summarise()` function takes a Ranges object and a set of name-value pairs
and aggregates the Ranges according to functions evaluated in the name-value pairs.
As `summarise()` is an aggregation it may break the structure of the of a Ranges
object, hence it returns a DataFrame object. The `select()` function determines
which metadata columns are returned and the order they are returned in. The 
`arrange()` function sorts a Ranges object by named variables.
The `group_by()` function creates an implicit grouping of Ranges object according
to variables in the Ranges object. This modifies the actions of `mutate()`,
`summarise()` and `filter()` (and also the set operations, `reduce_ranges()`
and `disjoin_ranges()`), so they are performed on each partition created by the
grouping. 

### Arithimetic 

The API has an expressive algebra for performing arithmetic on Ranges via
the verbs `set_width()` and `stretch()`. As the names suggest `set_width()`
modifies the width of a Ranges object, while `stretch` extends the start and
end of a Ranges object. These can be chained with the anchoring functions
`anchor_start()`, `anchor_end()`, `anchor_center()`, `anchor_3p()` or 
`anchor_5p()`, which fix the coordinates of a Ranges object in place. 
Moreover, the `shift_` and `flank_` family of functions can be used to shift
all coordinates in a Ranges object or generate flanking regions from a Ranges 
object to the left, right, upstream or downstream of the input. Unlike, the
Bioconductor API, _plyranges_ makes it expclit via function calls whether to
take into account the strand information of a _Ranges_ object.

### Overlapping Ranges

A common operation to perform between two _Ranges_ objects is to find overlaps
or nearest neighbours. The _plyranges_ API recasts these operations as 'joins'
or 'pairing' operations. For overlaps, there are three join operations: 
`join_overlap_intersect()`, `join_overlap_inner()` and `join_overlap_left()`
which are shown in figure (). These operations consider any overlap between
two input ranges and return any corresponding metadata from both Ranges objects
as metadata. The intersect join takes the intersect of the start and end coordinates
of overlapping intervals of the query and subject Ranges 
(for GenomicRanges it also accounts for sequence name), when there is a overlap
the metadata corresponding to the query and subject Ranges are returned. 
Similarly, inner join takes the start and end coordinates of the query Ranges
that overlap the subject Ranges and returns metadata of the overlapping query
and subject Ranges. Finally, the left join performs a left outer join between
the query and subject Ranges, it returns all genomic intervals from the query
ranges, and returns missing values in metadata columns when there is no overlap.
A user may also restrict or group by overlaps with the `filter_by_overlaps()`,
`filter_by_non_overlaps()` and `group_by_overlaps()`. All overlap methods can
be modified with the `within` suffix (which changes the type of overlap 
from 'any' to 'within') or the `directed` suffix (which takes into account
the strand of a GenomicRanges object.). 

For nearest neighbours, the `plyranges` API provides `join_nearest()`, 
`join_precede()`, and `join_follow()` functions. These functions are similar
to the overlapping functions, in that they return the query ranges that are
nearest (or precede or follow) the subject ranges and add metadata from
the subject ranges when the query is a nearest neighbour of the subject. Like
the overlap joins, these functions can modified with suffixes to find nearest
neighbours that are left, right, upstream or downstream of the subject.

The pairing operations, `pair_overlap()`, `pair_nearest()`, `pair_follow()`, 
and `pair_precede()` are similar to the join operation but instead of returning
a Ranges, they pair up the subject and query Ranges objects into a DataFrame,
alongside their metadata columns. This data structure is similar to the _Pairs_
data structure in the _S4Vectors_ package or the BED-PE file format. 
<!--- should also create convience methods for grouping by pairs and pairing up, 
unpairing, would also be useful for alignments too--->

### Non-standard evaluation 


# Results 

# Availablilty and Future Work

The _plyranges_ package is avaiable on the Bioconductor project website 
[https://bioconductor.org](https://bioconductor.org) or can be accessed
via Github [https://github.com/sa-lee/plyranges](https://github.com/sa-lee/plyranges).
We aim to continue developing the `plyranges` package and extend it for use
with more complex data structures outside of genomics such as the 
_SummarizedExperiment_ class. As the `plyranges` interface encourages tidy data 
practices it also integrates well with the grammar of graphics, we aim to use
it for the visualisation of genomic ranges.

# References {#references .unnumbered}
