% Template for PLoS
% Version 3.4 January 2017
\documentclass[10pt,letterpaper]{article}
\usepackage[top=0.85in,left=2.75in,footskip=0.75in]{geometry}

% amsmath and amssymb packages, useful for mathematical formulas and symbols
\usepackage{amsmath,amssymb}

% Use adjustwidth environment to exceed column width (see example table in text)
\usepackage{changepage}

% Use Unicode characters when possible
\usepackage[utf8x]{inputenc}

% textcomp package and marvosym package for additional characters
\usepackage{textcomp,marvosym}

% cite package, to clean up citations in the main text. Do not remove.
% \usepackage{cite}

% Use nameref to cite supporting information files (see Supporting Information section for more info)
\usepackage{nameref,hyperref}

% line numbers
\usepackage[right]{lineno}

% ligatures disabled
\usepackage{microtype}
\DisableLigatures[f]{encoding = *, family = * }

% color can be used to apply background shading to table cells only
\usepackage[table]{xcolor}

% array package and thick rules for tables
\usepackage{array}

% create "+" rule type for thick vertical lines
\newcolumntype{+}{!{\vrule width 2pt}}

% create \thickcline for thick horizontal lines of variable length
\newlength\savedwidth
\newcommand\thickcline[1]{%
  \noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
  \cline{#1}%
  \noalign{\vskip\arrayrulewidth}%
  \noalign{\global\arrayrulewidth\savedwidth}%
}

% \thickhline command for thick horizontal lines that span the table
\newcommand\thickhline{\noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
\hline
\noalign{\global\arrayrulewidth\savedwidth}}


% Remove comment for double spacing
%\usepackage{setspace} 
%\doublespacing

% Text layout
\raggedright
\setlength{\parindent}{0.5cm}
\textwidth 5.25in 
\textheight 8.75in

% Bold the 'Figure #' in the caption and separate it from the title/caption with a period
% Captions will be left justified
\usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
\renewcommand{\figurename}{Fig}

% Use the PLoS provided BiBTeX style
% \bibliographystyle{plos2015}

% Remove brackets from numbering in List of References
\makeatletter
\renewcommand{\@biblabel}[1]{\quad#1.}
\makeatother

% Leave date blank
\date{}

% Header and Footer with logo
\usepackage{lastpage,fancyhdr,graphicx}
\usepackage{epstopdf}
\pagestyle{myheadings}
\pagestyle{fancy}
\fancyhf{}
\setlength{\headheight}{27.023pt}
\lhead{\includegraphics[width=2.0in]{PLOS-submission.eps}}
\rfoot{\thepage/\pageref{LastPage}}
\renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
\fancyheadoffset[L]{2.25in}
\fancyfootoffset[L]{2.25in}
\lfoot{\sf PLOS}

%% Include all macros below
\newcommand{\lorem}{{\bf LOREM}}
\newcommand{\ipsum}{{\bf IPSUM}}

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}




\usepackage{forarray}
\usepackage{xstring}
\newcommand{\getIndex}[2]{
  \ForEach{,}{\IfEq{#1}{\thislevelitem}{\number\thislevelcount\ExitForEach}{}}{#2}
}

\setcounter{secnumdepth}{0}

\newcommand{\getAff}[1]{
  \getIndex{#1}{Monash University,Genentech}
}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\begin{document}
\vspace*{0.2in}

% Title must be 250 characters or less.
\begin{flushleft}
{\Large
\textbf\newline{plyranges: a grammar for manipulating genomics data} % Please use "sentence case" for title and headings (capitalize only the first word in a title (or heading), the first word in a subtitle (or subheading), and any proper nouns).
}
\newline
\\
Stuart Lee\textsuperscript{\getAff{Monash University}},
Michael Lawrence\textsuperscript{\getAff{Genentech}},
Di Cook\textsuperscript{\getAff{Monash University}}\\
\bigskip
\textbf{\getAff{Monash University}}Department of Econometrics and Business Statistics, Clayton, Victoria,
Australia\\
\textbf{\getAff{Genentech}}Bioinformatics and Computational Biology, Genentech, Inc., South San
Francisco, California, United States of America\\
\bigskip
\end{flushleft}
% Please keep the abstract below 300 words
\section*{Abstract}
The Bioconductor project has created many powerful abstractions for
reasoning about genomics data, such as the \emph{Ranges} data structures
for representing genomic intervals. By recognising that these data
structures follow `tidy' data principles we have created a grammar of
genomic data manipulation that defines verbs for performing actions on
and between genomic interval data. This grammar simplifies performing
common genomic data analysis tasks via a consistent interface to
existing Bioconductor infrastructure which results in creating human
readable analysis pipelines. We have implemented this grammar as an
Bioconductor/R package called plyranges.

% Please keep the Author Summary between 150 and 200 words
% Use first person. PLOS ONE authors please skip this step. 
% Author Summary not valid for PLOS ONE submissions.   

\linenumbers

% Use "Eq" instead of "Equation" for equation citations.
\section{Introduction}\label{introduction}

Genomic data may be naturally represented as sets of pairs of integers
corresponding to the start and end points of sequences. Further
information such as strandedness and chromosome name may be added to
these sets to provide biological context. Because of the flexibility of
this representation supplemental information such as measurements
obtained from an experimental assay or annotations from a genome
database can be joined to their relevant sequences. In the
Bioconductor/R packages \texttt{IRanges} and \texttt{GenomicRanges}
these representations have been implemented as a suite of data
structures called \emph{Ranges} {[}1{]}; {[}2{]}. These data structures
cover many common data types encountered in bioinformatics analyses. For
example, a gene can be represented with its coordinates, along with its
identifier and the identifiers of its exons; or an RNA-seq experiment
may be represented as sets of genes with a matching count column.

The Bioconductor infrastructure for computing with genomic ranges are
highly efficient and powerful, however the application programming
interface (API) for performing analysis tasks with \emph{Ranges} is
complex due to its large number of methods and classes. It also makes
resulting scripts written difficult for a non-programmer to read and
reason about. An alternative approach would be to implement a domain
specific language (DSL) as a fluent interface built on top \emph{Ranges}
{[}3{]}. The goal of a fluent interface is to enable users to write
human-readable code via method chaining and consistent function returns.
Fluent interfaces fit naturally in the context of bioinformatics
workflows because they enable writing succinct pipelines.

Several other DSLs have been implemented to reason about genomics data.
Broadly, these are either implemented as query languages or as command
line tools embedded in the Unix environment. An example of the former is
the Genome Query Language (GQL) and its distributed implementation GenAp
which use an SQL-like syntax for fast retrieval of information from
genomic databases and BAM files {[}4{]}; {[}5{]}. Another example is the
Genometric Query Language (GMQL) which implements a relational algebra
for combining big genomic datasets {[}6{]}.\\
The command line application BEDtools develops an extensive algebra for
performing arithmetic between two or more sets of genomic regions
{[}7{]}. It also has a python interface which simplifies constructing
scripts for performing analyses based on BEDTools {[}8{]}.

The abstraction provided by the \emph{Ranges} data structures aligns
with the concept of tidy data {[}9{]}. A tidy dataset is defined to be
to a tabular data structure that has observations as rows and columns as
variables, and each tidy dataset represents measurements from a single
observational unit. The tidy data pattern is useful because it allows us
to see how the data relates to the design of an experiment and the
variables measured. Consequently, it makes both the modelling and
manipulation of data more systematic. The \emph{Ranges} data structure
follows this abstraction: it is a rectangular table corresponding to a
single biological context. Each row contains a single observation and
each column is a variable about that observation.

The \emph{plyranges} API implements a domain specific language using the
existing \emph{IRanges} and \emph{GenomicRanges} packages in
Bioconductor as a back-end. Consequently, our API still has the speed
and efficiency of the aforementioned packages but with a more coherent
interface. The API also extends the grammar elements in \emph{dplyr}
{[}10{]} for performing genomic specific manipulations such as finding
overlapping regions or nearest neighbour regions between many
\emph{Ranges} . The \emph{plyranges} API is specifically designed to
enable fast interactive analysis of \emph{Ranges} objects but can also
be used for scripting genomic data workflows.

\section{Design and Implementation}\label{design-and-implementation}

We have designed the API to be fluent. Every function call corresponds
to an action on a \emph{Ranges} object (they are named verbs) and where
possible functions have few arguments. Each verb is constructed to
enable a tab completion based workflow. Both of these aspects reduce the
cognitive load on a new user since most manipulations can be performed
with a vocabulary of several verbs, rather than having to memorise
functions with many arguments that are nouns (as is required in the
existing Bioconductor packages). This is also has the advantage of
allowing users to write human readable code because verbs describe what
the code is doing rather than how its doing it.

Workflows can be composed by chaining verbs together via the forward
pipe operator,\texttt{\%\textgreater{}\%} (exported from the R package
\emph{magrittr} {[}11{]}). This is possible because every function call
is an endomorphism: when the input is \emph{Ranges} object the output
will also be a \emph{Ranges} object. One advantage of endomorphism is
that it does not require any additional learning of classes beyond
\emph{Ranges} and the \emph{DataFrame} classes. This strongly deviates
from the design of the \emph{Ranges} Bioconductor packages, where many
methods return a new class upon return. The Bioconductor design enables
efficient computing as users are exposed to low-level features of its
API which \emph{plyranges} abstracts away. Method chaining via the pipe
operator can also be difficult to debug, as there multiple points of
failure.

In order to provide a compatible API with \emph{dplyr}, \emph{plyranges}
makes extensive use of non-standard evaluation in R via the \emph{rlang}
package {[}12{]}. Simply, this means that computations are performed and
evaluated in the context of the \emph{Ranges} objects, which emphasises
the interactive nature of the API. This has the disadvantage that
programming with \emph{plyranges} becomes more difficult because a user
needs to capture expressions inside function calls and then unquote
them.

\subsection{Actions on Ranges}\label{actions-on-ranges}

The \emph{plyranges} API exports the six core verbs from the
\emph{dplyr} package and modifies them for use with \emph{Ranges}
objects. The verb \texttt{mutate()} takes a Ranges object and a set of
name-value pairs and generates a new Ranges object that with modified or
new metadata columns or modified core components (start, end, width,
seqnames, strand). The use of \texttt{mutate()} means that a user no
longer needs knowledge of the accessors of the Ranges object, as they
can modify them in place. The \texttt{filter()} function takes a Ranges
object and logical expressions and restricts Ranges object to where the
logical expression evaluates to true. The \texttt{summarise()} function
takes a Ranges object and a set of name-value pairs and aggregates the
Ranges according to functions evaluated in the name-value pairs. As
\texttt{summarise()} is an aggregation it may break the structure of the
of a Ranges object, hence it returns a \emph{DataFrame} object. The
\texttt{select()} function determines which metadata columns are
returned and the order they are returned in. The \texttt{arrange()}
function sorts a Ranges object by named variables. The
\texttt{group\_by()} function creates an implicit grouping of Ranges
object according to variables in the Ranges object. This modifies the
actions of \texttt{mutate()}, \texttt{summarise()} and
\texttt{filter()}, so they are performed on each partition created by
the grouping. The \texttt{group\_by()} operation acts as a replacement
for the \emph{GenomicRangesList} class in the original
\emph{GenomicRanges} API.

The \emph{plyranges} API introduces additional summary verbs,
\texttt{reduce\_ranges()} and \texttt{disjoin\_ranges()}that return
Ranges objects after being returned. The \texttt{reduce\_ranges()}
operation merges overlapping and neighbour ranges, while
\texttt{disjoin\_ranges()} expands ranges by taking the union of end
points.

\subsection{Arithimetic on Ranges}\label{arithimetic-on-ranges}

The \emph{plyranges} API has an expressive algebra for performing
arithmetic on Ranges via the verbs \texttt{set\_width()} and
\texttt{stretch()}. As the names suggest \texttt{set\_width()} modifies
the width of a Ranges object, while \texttt{stretch} extends the start
and end of a Ranges object. These can be chained with the anchoring
functions \texttt{anchor\_start()}, \texttt{anchor\_end()},
\texttt{anchor\_center()}, \texttt{anchor\_3p()} or
\texttt{anchor\_5p()}, which fix the coordinates of a Ranges object in
place. Moreover, the \texttt{shift\_} and \texttt{flank\_} family of
functions can be used to shift all coordinates in a Ranges object or
generate flanking regions from a Ranges object to the left, right,
upstream or downstream of the input. Unlike, the Bioconductor API,
\emph{plyranges} makes it explicit via function calls whether to take
into account the strand information of a \emph{Ranges} object.

\subsection{Overlapping Ranges}\label{overlapping-ranges}

A common operation to perform between two \emph{Ranges} objects is to
find overlaps or nearest neighbours. The \emph{plyranges} API recasts
these operations as `joins' or `pairing' operations. For overlaps, there
are three join operations: \texttt{join\_overlap\_intersect()},
\texttt{join\_overlap\_inner()} and \texttt{join\_overlap\_left()} which
are shown in figure (\ref{fig:olap}).

\begin{figure}

{\centering \includegraphics{paper_files/figure-latex/olap-1} 

}

\caption{The three overlap joins: the query and subject ranges are coloured by their metadata. When an overlap is performed the resulting range is filled by the query metadata and the metadata from the subject colours the outside of the range.}\label{fig:olap}
\end{figure}

These operations consider any overlap between two input ranges and
return any corresponding metadata from both Ranges objects as metadata.
The intersect join takes the intersect of the start and end coordinates
of overlapping intervals of the query and subject \emph{Ranges} (for
\emph{GenomicRanges} it also accounts for sequence name), when there is
a overlap the metadata corresponding to the query and subject
\emph{Ranges} are returned. Similarly, inner join takes the start and
end coordinates of the query \emph{Ranges} that overlap the subject
\emph{Ranges} and returns metadata of the overlapping query and subject
\emph{Ranges}. Finally, the left join performs a left outer join between
the query and subject \emph{Ranges}, it returns all genomic intervals
from the query ranges, and returns missing values in metadata columns
when there is no overlap.

A user may also restrict or group by overlaps with the
\texttt{filter\_by\_overlaps()}, \texttt{filter\_by\_non\_overlaps()}
and \texttt{group\_by\_overlaps()}. All overlap methods can be modified
with the \texttt{within} suffix (which changes the type of overlap from
`any' to `within') or the \texttt{directed} suffix (which takes into
account the strand of a \emph{GenomicRanges} object.).

For nearest neighbours, the \emph{plyranges} API provides
\texttt{join\_nearest()}, \texttt{join\_precede()}, and
\texttt{join\_follow()} functions. These functions are similar to the
overlapping functions, in that they return the query ranges that are
nearest (or precede or follow) the subject ranges and add metadata from
the subject ranges when the query is a nearest neighbour of the subject.
Like the overlap joins, these functions can modified with suffixes to
find nearest neighbours that are left, right, upstream or downstream of
the subject.

The pairing operations, \texttt{pair\_overlap()},
\texttt{pair\_nearest()}, \texttt{pair\_follow()}, and
\texttt{pair\_precede()} are similar to the join operation but instead
of returning a \emph{Ranges}, they pair up the subject and query
\emph{Ranges} objects into a \emph{DataFrame}, alongside their metadata
columns. This data structure is similar to the \emph{Pairs} data
structure in the \emph{S4Vectors} {[}13{]} package or the BED-PE file
format.

The combination of verbs we have defined above encapsulate all
operations that can be performed in the original \emph{IRanges} and
\emph{GenomicRanges} packages without the user be exposed to new
classes. In those packages to perform most operations requires users to
learn many classes and perform additional manipulations to return the
results of their computation back to a \emph{Ranges} object.

\subsection{Construction and
Import/Output}\label{construction-and-importoutput}

The methods \texttt{as\_granges()} and \texttt{as\_iranges()} for
constructing \emph{Ranges} from tabular data structures, such as the
\emph{data.frame} in base R. These methods use non-standard evaluation
so columns in a \emph{data.frame} can be modified before a \emph{Ranges}
object is created. The API also has convenience methods for annotating
or extracting annotations from \emph{GRanges} objects with the
\texttt{set\_genome\_info()} and \texttt{get\_genome\_info()} functions.

There is a consistent framework for reading and writing files from and
to common genomic data formats, using the \emph{rtracklayer} package as
a back-end {[}14{]}. The methods are implemented in the
\texttt{read\_/write\_} family of functions, currently \emph{plyranges}
can read and write BAM, BED, BEDPE, narrowPeaks, GFF/GTF, WIG and BigWig
files.

\section{Results}\label{results}

As an example, we use the Bioconductor package \emph{AnnotationHub}
{[}15{]} to search for BigWig files from ChIP-Seq experiments from the
Human Epigenome Roadmap project {[}16{]}. We choose to focus on assays
for primary T CD8+ memory cells from peripheral blood. We can then read
the BigWig file corresponding to the H3 lysine 27 trimethylation
(H3K27Me3) methylation mark over chromosome 10.

First, we gather the BigWig file and extract its annotation information
and filter it to chromosome 10.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(plyranges)}
\NormalTok{chr10_ranges <-}\StringTok{ }\NormalTok{bw_file }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{get_genome_info}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(seqnames }\OperatorTok{==}\StringTok{ "chr10"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Then we read the BigWig file only extracting scores if they overlap
chromosome 10. The annotation information from the file is automatically
included (in this case the hg19 genome build).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chr10_scores <-}\StringTok{ }\NormalTok{bw_file }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{read_bigwig}\NormalTok{(}\DataTypeTok{overlap_ranges =}\NormalTok{ chr10_ranges) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{set_genome_info}\NormalTok{(}\DataTypeTok{genome =} \StringTok{"hg19"}\NormalTok{)}
\NormalTok{chr10_scores}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
#> GRanges object with 5789841 ranges and 1 metadata column:
#>             seqnames                 ranges strand |              score
#>                <Rle>              <IRanges>  <Rle> |          <numeric>
#>         [1]    chr10         [    1, 60602]      * | 0.0422799997031689
#>         [2]    chr10         [60603, 60781]      * |  0.163240000605583
#>         [3]    chr10         [60782, 60816]      * |  0.372139990329742
#>         [4]    chr10         [60817, 60995]      * |  0.163240000605583
#>         [5]    chr10         [60996, 61625]      * | 0.0422799997031689
#>         ...      ...                    ...    ... .                ...
#>   [5789837]    chr10 [135524723, 135524734]      * |  0.144319996237755
#>   [5789838]    chr10 [135524735, 135524775]      * |  0.250230014324188
#>   [5789839]    chr10 [135524776, 135524784]      * |  0.427789986133575
#>   [5789840]    chr10 [135524785, 135524806]      * |  0.730019986629486
#>   [5789841]    chr10 [135524807, 135524837]      * |   1.03103005886078
#>   -------
#>   seqinfo: 25 sequences from hg19 genome
\end{verbatim}

The \texttt{reduce\_ranges()} operation is used to find coverage peaks
across chromosome 10. We can manually set a threshold to restrict
genomic regions to have a coverage score of greater than 8, and then
merge nearby regions. The maximum coverage is computed over all the
coverage scores in regions that were reduced.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_peaks <-}\StringTok{ }\NormalTok{chr10_scores }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(score }\OperatorTok{>}\StringTok{ }\DecValTok{8}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{reduce_ranges}\NormalTok{(}\DataTypeTok{score =} \KeywordTok{max}\NormalTok{(score))}
\end{Highlighting}
\end{Shaded}

Returning to the \emph{Ranges} object containing normalised coverage
scores for the methylation data, we can filter to find the coordinates
of the peak containing maximum coverage score. We can then find a 5000
nt region centered around the maximum position by anchoring and
modifying the the width.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chr10_max_score_region <-}\StringTok{ }\NormalTok{chr10_scores }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(score }\OperatorTok{==}\StringTok{ }\KeywordTok{max}\NormalTok{(score)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{anchor_center}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{set_width}\NormalTok{(}\DecValTok{5000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Finally, the overlap inner join could be used to restrict the chromosome
10 normalised coverage scores that are within the 5000nt region that
contains the max peak on chromosome 10 (visualised in figure
\ref{fig:peak-viz}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{peak_region <-}\StringTok{ }\NormalTok{chr10_scores }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{join_overlap_inner}\NormalTok{(chr10_max_score_region }\OperatorTok{%>%}\StringTok{ }
\StringTok{                       }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\NormalTok{score))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{paper_files/figure-latex/peak-viz-1} 

}

\caption{Visualisation of normalised coverage scores accross a 5000nt region of chromosome 10 from H3K27Me3 ChIP-Seq assay from the Human Epigenome Roadmap project.}\label{fig:peak-viz}
\end{figure}

\section{Availablilty and Future
Work}\label{availablilty-and-future-work}

The \emph{plyranges} package is available on the Bioconductor project
website \url{https://bioconductor.org} or can be accessed via Github
\url{https://github.com/sa-lee/plyranges}. We aim to continue developing
the \emph{plyranges} package and extend it for use with more complex
data structures such as the \emph{SummarizedExperiment} class, which can
be used for analysing transcriptomic and variant data. As the
\emph{plyranges} interface encourages tidy data practices it integrates
well with the principles of the grammar of graphics, we aim to use it
for the visualisation of multimodal biological datasets.

\section*{References}\label{references}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\hypertarget{ref-Lawrence2013-wg}{}
1. Lawrence M, Huber W, Pagès H, Aboyoun P, Carlson M, Gentleman R, et
al. Software for computing and annotating genomic ranges. PLoS Comput
Biol. 2013;9.
doi:\href{https://doi.org/10.1371/journal.pcbi.1003118}{10.1371/journal.pcbi.1003118}

\hypertarget{ref-Huber2015-ei}{}
2. Huber W, Carey VJ, Gentleman R, Anders S, Carlson M, Carvalho BS, et
al. Orchestrating high-throughput genomic analysis with bioconductor.
Nat Methods. Springer Nature; 2015;12: 115--121.
doi:\href{https://doi.org/10.1038/nmeth.3252}{10.1038/nmeth.3252}

\hypertarget{ref-Fowler2010-zd}{}
3. Fowler M. Domain-Specific languages {[}Internet{]}. Pearson
Education; 2010. Available:
\url{https://market.android.com/details?id=book-ri1muolw_YwC}

\hypertarget{ref-Kozanitis2014-va}{}
4. Kozanitis C, Heiberg A, Varghese G, Bafna V. Using genome query
language to uncover genetic variation. Bioinformatics. 2014;30: 1--8.
doi:\href{https://doi.org/10.1093/bioinformatics/btt250}{10.1093/bioinformatics/btt250}

\hypertarget{ref-Kozanitis2016-bm}{}
5. Kozanitis C, Patterson DA. GenAp: A distributed SQL interface for
genomic data. BMC Bioinformatics. 2016;17: 63.
doi:\href{https://doi.org/10.1186/s12859-016-0904-1}{10.1186/s12859-016-0904-1}

\hypertarget{ref-Kaitoua2017-pw}{}
6. Kaitoua A, Pinoli P, Bertoni M, Ceri S. Framework for supporting
genomic operations. IEEE Trans Comput. 2017;66: 443--457.
doi:\href{https://doi.org/10.1109/TC.2016.2603980}{10.1109/TC.2016.2603980}

\hypertarget{ref-Quinlan2010-gc}{}
7. Quinlan AR, Hall IM. BEDTools: A flexible suite of utilities for
comparing genomic features. Bioinformatics. 2010;26: 841--842.
doi:\href{https://doi.org/10.1093/bioinformatics/btq033}{10.1093/bioinformatics/btq033}

\hypertarget{ref-Dale2011-js}{}
8. Dale RK, Pedersen BS, Quinlan AR. Pybedtools: A flexible python
library for manipulating genomic datasets and annotations.
Bioinformatics. 2011;27: 3423--3424.
doi:\href{https://doi.org/10.1093/bioinformatics/btr539}{10.1093/bioinformatics/btr539}

\hypertarget{ref-Wickham2014-jc}{}
9. Wickham H. Tidy data. Journal of Statistical Software, Articles.
2014;59: 1--23.
doi:\href{https://doi.org/10.18637/jss.v059.i10}{10.18637/jss.v059.i10}

\hypertarget{ref-Wickham2017-dplyr}{}
10. Wickham H, Francois R, Henry L, Müller K. Dplyr: A grammar of data
manipulation {[}Internet{]}. 2017. Available:
\url{https://CRAN.R-project.org/package=dplyr}

\hypertarget{ref-R-magrittr}{}
11. Bache SM, Wickham H. Magrittr: A forward-pipe operator for r
{[}Internet{]}. 2014. Available:
\url{https://CRAN.R-project.org/package=magrittr}

\hypertarget{ref-R-rlang}{}
12. Henry L, Wickham H. Rlang: Functions for base types and core r and
'tidyverse' features {[}Internet{]}. 2017. Available:
\url{http://rlang.tidyverse.org}

\hypertarget{ref-R-S4vectors}{}
13. Pagès H, Lawrence M, Aboyoun P. S4Vectors: S4 implementation of
vector-like and list-like objects. 2017.

\hypertarget{ref-Lawrence2009-nt}{}
14. Lawrence M, Gentleman R, Carey V. Rtracklayer: An R package for
interfacing with genome browsers. Bioinformatics. 2009;25: 1841--1842.
doi:\href{https://doi.org/10.1093/bioinformatics/btp328}{10.1093/bioinformatics/btp328}

\hypertarget{ref-R-ahub}{}
15. Morgan M. AnnotationHub: Client to access annotationhub resources.
2017.

\hypertarget{ref-Roadmap_Epigenomics_Consortium2015-pr}{}
16. Roadmap Epigenomics Consortium, Kundaje A, Meuleman W, Ernst J,
Bilenky M, Yen A, et al. Integrative analysis of 111 reference human
epigenomes. Nature. 2015;518: 317--330.
doi:\href{https://doi.org/10.1038/nature14248}{10.1038/nature14248}

\nolinenumbers


\end{document}

